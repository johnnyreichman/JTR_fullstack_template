{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2017-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n *     http://aws.amazon.com/apache2.0/\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n\nvar __assign = this && this.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n  }\n\n  return t;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Logger_1 = require(\"./Logger\");\n\nvar logger = new Logger_1.ConsoleLogger('Hub');\nvar AMPLIFY_SYMBOL = typeof Symbol !== 'undefined' && typeof Symbol.for === 'function' ? Symbol.for('amplify_default') : '@@amplify_default';\n\nfunction isLegacyCallback(callback) {\n  return callback.onHubCapsule !== undefined;\n}\n\nvar HubClass =\n/** @class */\nfunction () {\n  function HubClass(name) {\n    this.listeners = [];\n    this.patterns = [];\n    this.protectedChannels = ['core', 'auth', 'api', 'analytics', 'interactions', 'pubsub', 'storage', 'xr'];\n    this.name = name;\n  } // Note - Need to pass channel as a reference for removal to work and not anonymous function\n\n\n  HubClass.prototype.remove = function (channel, listener) {\n    if (channel instanceof RegExp) {\n      var pattern_1 = this.patterns.find(function (_a) {\n        var pattern = _a.pattern;\n        return pattern.source === channel.source;\n      });\n\n      if (!pattern_1) {\n        logger.warn(\"No listeners for \" + channel);\n        return;\n      }\n\n      this.patterns = this.patterns.filter(function (x) {\n        return x !== pattern_1;\n      }).slice();\n    } else {\n      var holder = this.listeners[channel];\n\n      if (!holder) {\n        logger.warn(\"No listeners for \" + channel);\n        return;\n      }\n\n      this.listeners[channel] = holder.filter(function (_a) {\n        var callback = _a.callback;\n        return callback !== listener;\n      }).slice();\n    }\n  };\n\n  HubClass.prototype.dispatch = function (channel, payload, source, ampSymbol) {\n    if (source === void 0) {\n      source = '';\n    }\n\n    if (this.protectedChannels.indexOf(channel) > -1) {\n      var hasAccess = ampSymbol === AMPLIFY_SYMBOL;\n\n      if (!hasAccess) {\n        logger.warn(\"WARNING: \" + channel + \" is protected and dispatching on it can have unintended consequences\");\n      }\n    }\n\n    var capsule = {\n      channel: channel,\n      payload: __assign({}, payload),\n      source: source,\n      patternInfo: []\n    };\n\n    try {\n      this._toListeners(capsule);\n    } catch (e) {\n      logger.error(e);\n    }\n  };\n\n  HubClass.prototype.listen = function (channel, callback, listenerName) {\n    if (listenerName === void 0) {\n      listenerName = 'noname';\n    }\n\n    var cb; // Check for legacy onHubCapsule callback for backwards compatability\n\n    if (isLegacyCallback(callback)) {\n      logger.warn(\"WARNING onHubCapsule is Deprecated. Please pass in a callback.\");\n      cb = callback.onHubCapsule.bind(callback);\n    } else if (typeof callback !== 'function') {\n      throw new Error('No callback supplied to Hub');\n    } else {\n      cb = callback;\n    }\n\n    if (channel instanceof RegExp) {\n      this.patterns.push({\n        pattern: channel,\n        callback: cb\n      });\n    } else {\n      var holder = this.listeners[channel];\n\n      if (!holder) {\n        holder = [];\n        this.listeners[channel] = holder;\n      }\n\n      holder.push({\n        name: listenerName,\n        callback: cb\n      });\n    }\n  };\n\n  HubClass.prototype._toListeners = function (capsule) {\n    var channel = capsule.channel,\n        payload = capsule.payload;\n    var holder = this.listeners[channel];\n\n    if (holder) {\n      holder.forEach(function (listener) {\n        logger.debug(\"Dispatching to \" + channel + \" with \", payload);\n\n        try {\n          listener.callback(capsule);\n        } catch (e) {\n          logger.error(e);\n        }\n      });\n    }\n\n    if (this.patterns.length > 0) {\n      if (!payload.message) {\n        logger.warn(\"Cannot perform pattern matching without a message key\");\n        return;\n      }\n\n      var payloadStr_1 = payload.message;\n      this.patterns.forEach(function (pattern) {\n        var match = payloadStr_1.match(pattern.pattern);\n\n        if (match) {\n          var groups = match.slice(1);\n\n          var dispatchingCapsule = __assign({}, capsule, {\n            patternInfo: groups\n          });\n\n          try {\n            pattern.callback(dispatchingCapsule);\n          } catch (e) {\n            logger.error(e);\n          }\n        }\n      });\n    }\n  };\n\n  return HubClass;\n}();\n\nexports.HubClass = HubClass;\n/*We export a __default__ instance of HubClass to use it as a\npsuedo Singleton for the main messaging bus, however you can still create\nyour own instance of HubClass() for a separate \"private bus\" of events.*/\n\nvar Hub = new HubClass('__default__');\nexports.default = Hub;","map":{"version":3,"sources":["../src/Hub.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2017-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n *     http://aws.amazon.com/apache2.0/\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Logger_1 = require(\"./Logger\");\nvar logger = new Logger_1.ConsoleLogger('Hub');\nvar AMPLIFY_SYMBOL = ((typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') ?\n    Symbol.for('amplify_default') : '@@amplify_default');\nfunction isLegacyCallback(callback) {\n    return callback.onHubCapsule !== undefined;\n}\nvar HubClass = /** @class */ (function () {\n    function HubClass(name) {\n        this.listeners = [];\n        this.patterns = [];\n        this.protectedChannels = ['core', 'auth', 'api', 'analytics', 'interactions', 'pubsub', 'storage', 'xr'];\n        this.name = name;\n    }\n    // Note - Need to pass channel as a reference for removal to work and not anonymous function\n    HubClass.prototype.remove = function (channel, listener) {\n        if (channel instanceof RegExp) {\n            var pattern_1 = this.patterns.find(function (_a) {\n                var pattern = _a.pattern;\n                return pattern.source === channel.source;\n            });\n            if (!pattern_1) {\n                logger.warn(\"No listeners for \" + channel);\n                return;\n            }\n            this.patterns = this.patterns.filter(function (x) { return x !== pattern_1; }).slice();\n        }\n        else {\n            var holder = this.listeners[channel];\n            if (!holder) {\n                logger.warn(\"No listeners for \" + channel);\n                return;\n            }\n            this.listeners[channel] = holder.filter(function (_a) {\n                var callback = _a.callback;\n                return callback !== listener;\n            }).slice();\n        }\n    };\n    HubClass.prototype.dispatch = function (channel, payload, source, ampSymbol) {\n        if (source === void 0) { source = ''; }\n        if (this.protectedChannels.indexOf(channel) > -1) {\n            var hasAccess = ampSymbol === AMPLIFY_SYMBOL;\n            if (!hasAccess) {\n                logger.warn(\"WARNING: \" + channel + \" is protected and dispatching on it can have unintended consequences\");\n            }\n        }\n        var capsule = {\n            channel: channel,\n            payload: __assign({}, payload),\n            source: source,\n            patternInfo: []\n        };\n        try {\n            this._toListeners(capsule);\n        }\n        catch (e) {\n            logger.error(e);\n        }\n    };\n    HubClass.prototype.listen = function (channel, callback, listenerName) {\n        if (listenerName === void 0) { listenerName = 'noname'; }\n        var cb;\n        // Check for legacy onHubCapsule callback for backwards compatability\n        if (isLegacyCallback(callback)) {\n            logger.warn(\"WARNING onHubCapsule is Deprecated. Please pass in a callback.\");\n            cb = callback.onHubCapsule.bind(callback);\n        }\n        else if (typeof callback !== 'function') {\n            throw new Error('No callback supplied to Hub');\n        }\n        else {\n            cb = callback;\n        }\n        if (channel instanceof RegExp) {\n            this.patterns.push({\n                pattern: channel,\n                callback: cb\n            });\n        }\n        else {\n            var holder = this.listeners[channel];\n            if (!holder) {\n                holder = [];\n                this.listeners[channel] = holder;\n            }\n            holder.push({\n                name: listenerName,\n                callback: cb\n            });\n        }\n    };\n    HubClass.prototype._toListeners = function (capsule) {\n        var channel = capsule.channel, payload = capsule.payload;\n        var holder = this.listeners[channel];\n        if (holder) {\n            holder.forEach(function (listener) {\n                logger.debug(\"Dispatching to \" + channel + \" with \", payload);\n                try {\n                    listener.callback(capsule);\n                }\n                catch (e) {\n                    logger.error(e);\n                }\n            });\n        }\n        if (this.patterns.length > 0) {\n            if (!payload.message) {\n                logger.warn(\"Cannot perform pattern matching without a message key\");\n                return;\n            }\n            var payloadStr_1 = payload.message;\n            this.patterns.forEach(function (pattern) {\n                var match = payloadStr_1.match(pattern.pattern);\n                if (match) {\n                    var groups = match.slice(1);\n                    var dispatchingCapsule = __assign({}, capsule, { patternInfo: groups });\n                    try {\n                        pattern.callback(dispatchingCapsule);\n                    }\n                    catch (e) {\n                        logger.error(e);\n                    }\n                }\n            });\n        }\n    };\n    return HubClass;\n}());\nexports.HubClass = HubClass;\n/*We export a __default__ instance of HubClass to use it as a\npsuedo Singleton for the main messaging bus, however you can still create\nyour own instance of HubClass() for a separate \"private bus\" of events.*/\nvar Hub = new HubClass('__default__');\nexports.default = Hub;\n//# sourceMappingURL=Hub.js.map"]},"metadata":{},"sourceType":"script"}